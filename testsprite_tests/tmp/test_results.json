[
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "5f4da870-b5d1-4178-b2a5-e65c6bb2133c",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC001-test_user_authentication_endpoints",
    "description": "Verify the user authentication system including login, registration, password recovery, and biometric authentication endpoints for correct functionality, security, and error handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\nTIMEOUT = 30\n\n\ndef graphql_request(query, variables=None, headers=None):\n    json_data = {\"query\": query}\n    if variables is not None:\n        json_data[\"variables\"] = variables\n    response = requests.post(\n        BASE_URL, json=json_data, headers=headers or HEADERS, timeout=TIMEOUT\n    )\n    response.raise_for_status()\n    return response.json()\n\n\ndef test_user_authentication_endpoints():\n    # 1. Register a new user\n    unique_email = f\"testuser_{uuid.uuid4().hex}@example.com\"\n    register_mutation = \"\"\"\n    mutation Register($email: String!, $password: String!) {\n      registerUser(email: $email, password: $password) {\n        success\n        message\n        user {\n          id\n          email\n        }\n        errors\n      }\n    }\n    \"\"\"\n    variables = {\"email\": unique_email, \"password\": \"StrongPassw0rd!\"}\n    register_resp = graphql_request(register_mutation, variables)\n    assert \"data\" in register_resp and register_resp[\"data\"] is not None, \"No data in register response\"\n    assert \"registerUser\" in register_resp[\"data\"] and register_resp[\"data\"][\"registerUser\"] is not None, \"No registerUser data\"\n    reg_data = register_resp[\"data\"][\"registerUser\"]\n    assert reg_data[\"success\"] is True, f\"Registration failed: {reg_data.get('message') or reg_data.get('errors')}\"\n\n    user_id = reg_data[\"user\"][\"id\"]\n    assert reg_data[\"user\"][\"email\"] == unique_email\n\n    token = None\n\n    try:\n        # 2. Login with the newly registered user\n        login_mutation = \"\"\"\n        mutation Login($email: String!, $password: String!) {\n          loginUser(email: $email, password: $password) {\n            success\n            message\n            token\n            errors\n          }\n        }\n        \"\"\"\n        variables = {\"email\": unique_email, \"password\": \"StrongPassw0rd!\"}\n        login_resp = graphql_request(login_mutation, variables)\n        assert \"data\" in login_resp and login_resp[\"data\"] is not None, \"No data in login response\"\n        assert \"loginUser\" in login_resp[\"data\"] and login_resp[\"data\"][\"loginUser\"] is not None, \"No loginUser data\"\n        login_data = login_resp[\"data\"][\"loginUser\"]\n        assert login_data[\"success\"] is True, f\"Login failed: {login_data.get('message') or login_data.get('errors')}\"\n        token = login_data.get(\"token\")\n        assert token is not None and isinstance(token, str) and len(token) > 0\n\n        auth_headers = HEADERS.copy()\n        auth_headers[\"Authorization\"] = f\"Bearer {token}\"\n\n        # 3. Password Recovery Request\n        password_recovery_mutation = \"\"\"\n        mutation RequestPasswordRecovery($email: String!) {\n          requestPasswordRecovery(email: $email) {\n            success\n            message\n            errors\n          }\n        }\n        \"\"\"\n        variables = {\"email\": unique_email}\n        recovery_resp = graphql_request(password_recovery_mutation, variables)\n        assert \"data\" in recovery_resp and recovery_resp[\"data\"] is not None, \"No data in password recovery response\"\n        assert \"requestPasswordRecovery\" in recovery_resp[\"data\"] and recovery_resp[\"data\"][\"requestPasswordRecovery\"] is not None, \"No requestPasswordRecovery data\"\n        recovery_data = recovery_resp[\"data\"][\"requestPasswordRecovery\"]\n        # Accept success or message to acknowledge email sent, may be true even if email not found for security\n        assert recovery_data[\"success\"] is True or \"sent\" in (recovery_data.get(\"message\") or \"\").lower()\n\n        # 4. Biometric Authentication Simulation (Assuming this requires a token or flag)\n        # Since biometric is optional, test an endpoint that simulates biometric verification\n        biometric_auth_mutation = \"\"\"\n        mutation BiometricAuth($userId: ID!, $biometricToken: String!) {\n          biometricAuthenticate(userId: $userId, biometricToken: $biometricToken) {\n            success\n            message\n            token\n            errors\n          }\n        }\n        \"\"\"\n        variables = {\"userId\": user_id, \"biometricToken\": \"dummy_biometric_token\"}\n        biometric_resp = graphql_request(biometric_auth_mutation, variables)\n        assert \"data\" in biometric_resp and biometric_resp[\"data\"] is not None, \"No data in biometric auth response\"\n        assert \"biometricAuthenticate\" in biometric_resp[\"data\"] and biometric_resp[\"data\"][\"biometricAuthenticate\"] is not None, \"No biometricAuthenticate data\"\n        biometric_data = biometric_resp[\"data\"][\"biometricAuthenticate\"]\n\n        # It's possible biometric auth is disabled or not implemented for dummy token - accept success or specific error\n        assert (\n            biometric_data[\"success\"] is True or biometric_data[\"success\"] is False\n        ), \"Biometric auth endpoint should respond with success or failure state\"\n\n        # 5. Negative tests:\n        # - Login with wrong password\n        variables = {\"email\": unique_email, \"password\": \"WrongPassword123!\"}\n        login_fail_resp = graphql_request(login_mutation, variables)\n        assert \"data\" in login_fail_resp and login_fail_resp[\"data\"] is not None, \"No data in failed login response\"\n        assert \"loginUser\" in login_fail_resp[\"data\"] and login_fail_resp[\"data\"][\"loginUser\"] is not None, \"No loginUser data in failed login response\"\n        login_fail_data = login_fail_resp[\"data\"][\"loginUser\"]\n        assert (\n            login_fail_data[\"success\"] is False\n        ), \"Login should fail with wrong password\"\n        assert login_fail_data.get(\"errors\") is not None or login_fail_data.get(\n            \"message\"\n        ), \"Error details should be provided for failed login\"\n\n        # - Register with duplicate email\n        variables = {\"email\": unique_email, \"password\": \"AnotherPassw0rd!\"}\n        register_dup_resp = graphql_request(register_mutation, variables)\n        assert \"data\" in register_dup_resp and register_dup_resp[\"data\"] is not None, \"No data in duplicate register response\"\n        assert \"registerUser\" in register_dup_resp[\"data\"] and register_dup_resp[\"data\"][\"registerUser\"] is not None, \"No registerUser data for duplicate registration\"\n        reg_dup_data = register_dup_resp[\"data\"][\"registerUser\"]\n        assert (\n            reg_dup_data[\"success\"] is False\n        ), \"Registration should fail for duplicate email\"\n        assert reg_dup_data.get(\"errors\") is not None or reg_dup_data.get(\n            \"message\"\n        ), \"Error details should be provided for duplicate registration\"\n\n    finally:\n        # Cleanup: delete the test user if delete mutation available\n        delete_user_mutation = \"\"\"\n        mutation DeleteUser($userId: ID!) {\n          deleteUser(userId: $userId) {\n            success\n            message\n            errors\n          }\n        }\n        \"\"\"\n        # Use admin auth or token if required - here assuming no auth or reuse biometric or login token\n        try:\n            # Try to delete with token if available\n            del_headers = HEADERS.copy()\n            if token is not None:\n                del_headers[\"Authorization\"] = f\"Bearer {token}\"\n            del_vars = {\"userId\": user_id}\n            del_resp = requests.post(\n                BASE_URL,\n                json={\"query\": delete_user_mutation, \"variables\": del_vars},\n                headers=del_headers,\n                timeout=TIMEOUT,\n            )\n            if del_resp.status_code == 200:\n                del_json = del_resp.json()\n                if \"data\" in del_json and del_json[\"data\"].get(\"deleteUser\"):\n                    # No strict assert here, best effort cleanup\n                    pass\n        except Exception:\n            pass\n\n\ntest_user_authentication_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 175, in <module>\n  File \"<string>\", line 40, in test_user_authentication_endpoints\nAssertionError: No data in register response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:34.977Z",
    "modified": "2025-11-11T04:10:17.735Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "c49e0861-82e6-41f6-9193-8da7a7a98a1f",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC002-test_onboarding_flow_endpoints",
    "description": "Test the onboarding flow endpoints to ensure proper child profile setup and initial configuration are handled correctly for first-time users.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\nheaders = {\n    \"Content-Type\": \"application/json\",\n}\n\ndef graphql_request(query, variables=None, token=None):\n    payload = {\n        \"query\": query,\n        \"variables\": variables or {}\n    }\n    hdrs = headers.copy()\n    if token:\n        hdrs[\"Authorization\"] = f\"Bearer {token}\"\n    response = requests.post(BASE_URL, json=payload, headers=hdrs, timeout=TIMEOUT)\n    response.raise_for_status()\n    json_resp = response.json()\n    assert \"errors\" not in json_resp, f\"GraphQL errors: {json_resp.get('errors')}\"\n    return json_resp[\"data\"]\n\ndef test_onboarding_flow_endpoints():\n    # 1. Register a new user (first-time user)\n    register_mutation = \"\"\"\n    mutation RegisterUser($email: String!, $password: String!) {\n      registerUser(email: $email, password: $password) {\n        success\n        user {\n          id\n          email\n        }\n        token\n      }\n    }\n    \"\"\"\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    register_vars = {\n        \"email\": unique_email,\n        \"password\": \"StrongP@ssword123!\"\n    }\n    register_data = graphql_request(register_mutation, register_vars)\n    assert register_data[\"registerUser\"][\"success\"] is True\n    user_id = register_data[\"registerUser\"][\"user\"][\"id\"]\n    token = register_data[\"registerUser\"][\"token\"]\n    assert user_id and token\n\n    # Use try-finally to remove created resources, if deletions are possible\n    try:\n        # 2. Onboarding: Create child profile for first-time user\n        create_child_mutation = \"\"\"\n        mutation CreateChild($input: CreateChildInput!) {\n          createChild(input: $input) {\n            child {\n              id\n              name\n              birthDate\n              gender\n            }\n          }\n        }\n        \"\"\"\n        child_name = \"BabyOnboard\"\n        birth_date = \"2024-01-01\"\n        gender = \"FEMALE\"\n        child_vars = {\n            \"input\": {\n                \"name\": child_name,\n                \"birthDate\": birth_date,\n                \"gender\": gender\n            }\n        }\n        child_create_data = graphql_request(create_child_mutation, child_vars, token)\n        child = child_create_data[\"createChild\"][\"child\"]\n        assert child[\"name\"] == child_name\n        assert child[\"birthDate\"] == birth_date\n        assert child[\"gender\"] == gender\n        child_id = child[\"id\"]\n        assert child_id\n\n        # 3. Onboarding: Initial diaper inventory setup for the child\n        create_inventory_mutation = \"\"\"\n        mutation AddInventoryItem($input: AddInventoryItemInput!) {\n          addInventoryItem(input: $input) {\n            inventoryItem {\n              id\n              childId\n              size\n              quantity\n              status\n            }\n          }\n        }\n        \"\"\"\n        inventory_vars = {\n            \"input\": {\n                \"childId\": child_id,\n                \"size\": \"NEWBORN\",\n                \"quantity\": 20,\n                \"status\": \"GREEN\"\n            }\n        }\n        inventory_data = graphql_request(create_inventory_mutation, inventory_vars, token)\n        inventory_item = inventory_data[\"addInventoryItem\"][\"inventoryItem\"]\n        assert inventory_item[\"childId\"] == child_id\n        assert inventory_item[\"size\"] == \"NEWBORN\"\n        assert inventory_item[\"quantity\"] == 20\n        assert inventory_item[\"status\"] == \"GREEN\"\n        inventory_item_id = inventory_item[\"id\"]\n\n        # 4. Query user profile with children and inventory to validate setup\n        get_user_profile_query = \"\"\"\n        query GetUserProfile {\n          me {\n            id\n            email\n            children {\n              id\n              name\n              birthDate\n              gender\n              inventory {\n                id\n                size\n                quantity\n                status\n              }\n            }\n          }\n        }\n        \"\"\"\n        profile_data = graphql_request(get_user_profile_query, token=token)\n        me = profile_data[\"me\"]\n        assert me[\"id\"] == user_id\n        # Validate the created child is present\n        found_child = next((c for c in me[\"children\"] if c[\"id\"] == child_id), None)\n        assert found_child is not None\n        assert found_child[\"name\"] == child_name\n        # Validate inventory under the child\n        inv = found_child[\"inventory\"]\n        assert any(i[\"id\"] == inventory_item_id for i in inv)\n\n        # 5. Fetch ML-powered reorder suggestions for the child (simulate first-time suggestions)\n        reorder_suggestions_query = \"\"\"\n        query ReorderSuggestions($childId: ID!) {\n          reorderSuggestions(childId: $childId) {\n            suggestedSize\n            recommendedQuantity\n            retailerComparisons {\n              retailerName\n              price\n            }\n            emergencyOrderAvailable\n          }\n        }\n        \"\"\"\n        reorder_vars = {\"childId\": child_id}\n        reorder_data = graphql_request(reorder_suggestions_query, reorder_vars, token)\n        suggestions = reorder_data[\"reorderSuggestions\"]\n        # Should return suggestions structure (can be empty but keys present)\n        assert \"suggestedSize\" in suggestions\n        assert \"recommendedQuantity\" in suggestions\n        assert isinstance(suggestions.get(\"retailerComparisons\", []), list)\n        assert isinstance(suggestions.get(\"emergencyOrderAvailable\"), bool)\n\n        # 6. Fetch analytics dashboard data for the user/child\n        analytics_query = \"\"\"\n        query AnalyticsData($childId: ID!) {\n          analytics(childId: $childId) {\n            usageTrends {\n              diaperUsagePerDay\n              lastWeekUsage\n            }\n            costSummary {\n              totalSpent\n              savings\n            }\n            sizeChangePredictions {\n              predictedSize\n              predictedDate\n            }\n          }\n        }\n        \"\"\"\n        analytics_vars = {\"childId\": child_id}\n        analytics_data = graphql_request(analytics_query, analytics_vars, token)\n        analytics = analytics_data[\"analytics\"]\n        # Validate keys exist in analytics response\n        assert \"usageTrends\" in analytics\n        assert \"costSummary\" in analytics\n        assert \"sizeChangePredictions\" in analytics\n\n    finally:\n        # Cleanup: delete inventory item\n        try:\n            delete_inventory_mutation = \"\"\"\n            mutation DeleteInventoryItem($id: ID!) {\n              deleteInventoryItem(id: $id) {\n                success\n              }\n            }\n            \"\"\"\n            if 'inventory_item_id' in locals():\n                graphql_request(delete_inventory_mutation, {\"id\": inventory_item_id}, token)\n        except Exception:\n            pass\n\n        # Cleanup: delete child profile\n        try:\n            delete_child_mutation = \"\"\"\n            mutation DeleteChild($id: ID!) {\n              deleteChild(id: $id) {\n                success\n              }\n            }\n            \"\"\"\n            if 'child_id' in locals():\n                graphql_request(delete_child_mutation, {\"id\": child_id}, token)\n        except Exception:\n            pass\n\n        # Cleanup: delete user\n        try:\n            delete_user_mutation = \"\"\"\n            mutation DeleteUser {\n              deleteMe {\n                success\n              }\n            }\n            \"\"\"\n            graphql_request(delete_user_mutation, token=token)\n        except Exception:\n            pass\n\ntest_onboarding_flow_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 237, in <module>\n  File \"<string>\", line 44, in test_onboarding_flow_endpoints\n  File \"<string>\", line 22, in graphql_request\nAssertionError: GraphQL errors: [{'message': \"Cannot query field 'registerUser' on type 'Mutation'.\", 'locations': [{'line': 3, 'column': 7}]}]\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:34.984Z",
    "modified": "2025-11-11T04:10:25.769Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "c9be48f4-070e-4eb4-8e41-2af8c3d6cf33",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC003-test_child_profile_management_endpoints",
    "description": "Validate the child profile management APIs for creating, editing, retrieving, and deleting child profiles with accurate data reflection and permission checks.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\nUSERNAME = \"testuser@example.com\"\nPASSWORD = \"TestPassword123!\"\n\ndef get_auth_token():\n    login_mutation = \"\"\"\n    mutation SignIn($input: SignInInput!) {\n      signIn(input: $input) {\n        user {\n          id\n          email\n        }\n      }\n    }\n    \"\"\"\n    variables = {\"input\": {\"email\": USERNAME, \"password\": PASSWORD}}\n    response = requests.post(\n        BASE_URL,\n        json={\"query\": login_mutation, \"variables\": variables},\n        timeout=TIMEOUT\n    )\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Login errors: {data.get('errors')}\"\n\n    user = data[\"data\"][\"signIn\"][\"user\"]\n    assert user is not None, \"User missing in login response\"\n    assert user[\"email\"] == USERNAME\n    # As no token is returned per schema error, return None\n    return None\n\ndef test_child_profile_management_endpoints():\n    token = get_auth_token()\n    headers = {}\n    if token:\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    create_child_mutation = \"\"\"\n    mutation CreateChildProfile($input: ChildProfileInput!) {\n      createChildProfile(input: $input) {\n        id\n        firstName\n        lastName\n        birthDate\n        gender\n      }\n    }\n    \"\"\"\n    get_child_query = \"\"\"\n    query GetChildProfile($id: ID!) {\n      childProfile(id: $id) {\n        id\n        firstName\n        lastName\n        birthDate\n        gender\n      }\n    }\n    \"\"\"\n    update_child_mutation = \"\"\"\n    mutation UpdateChildProfile($id: ID!, $input: ChildProfileUpdateInput!) {\n      updateChildProfile(id: $id, input: $input) {\n        id\n        firstName\n        lastName\n        birthDate\n        gender\n      }\n    }\n    \"\"\"\n    delete_child_mutation = \"\"\"\n    mutation DeleteChildProfile($id: ID!) {\n      deleteChildProfile(id: $id) {\n        success\n        message\n      }\n    }\n    \"\"\"\n\n    child_first_name = f\"TestChild{uuid.uuid4().hex[:6]}\"\n    child_create_input = {\n        \"firstName\": child_first_name,\n        \"lastName\": \"Tester\",\n        \"birthDate\": \"2023-01-15\",\n        \"gender\": \"Female\"\n    }\n\n    child_id = None\n    try:\n        create_resp = requests.post(\n            BASE_URL,\n            headers=headers,\n            json={\"query\": create_child_mutation, \"variables\": {\"input\": child_create_input}},\n            timeout=TIMEOUT\n        )\n        create_resp.raise_for_status()\n        create_data = create_resp.json()\n        assert \"errors\" not in create_data, f\"Create child profile errors: {create_data.get('errors')}\"\n        created_child = create_data[\"data\"][\"createChildProfile\"]\n        assert created_child[\"firstName\"] == child_create_input[\"firstName\"]\n        assert created_child[\"lastName\"] == child_create_input[\"lastName\"]\n        assert created_child[\"birthDate\"] == child_create_input[\"birthDate\"]\n        assert created_child[\"gender\"] == child_create_input[\"gender\"]\n        child_id = created_child[\"id\"]\n        assert child_id is not None\n\n        get_resp = requests.post(\n            BASE_URL,\n            headers=headers,\n            json={\"query\": get_child_query, \"variables\": {\"id\": child_id}},\n            timeout=TIMEOUT\n        )\n        get_resp.raise_for_status()\n        get_data = get_resp.json()\n        assert \"errors\" not in get_data, f\"Get child profile errors: {get_data.get('errors')}\"\n        fetched_child = get_data[\"data\"][\"childProfile\"]\n        assert fetched_child[\"id\"] == child_id\n        assert fetched_child[\"firstName\"] == child_create_input[\"firstName\"]\n        assert fetched_child[\"lastName\"] == child_create_input[\"lastName\"]\n        assert fetched_child[\"birthDate\"] == child_create_input[\"birthDate\"]\n        assert fetched_child[\"gender\"] == child_create_input[\"gender\"]\n\n        updated_first_name = child_first_name + \"Updated\"\n        update_input = {\n            \"firstName\": updated_first_name,\n            \"lastName\": \"TesterUpdated\",\n            \"birthDate\": \"2023-01-20\",\n            \"gender\": \"Female\"\n        }\n        update_resp = requests.post(\n            BASE_URL,\n            headers=headers,\n            json={\"query\": update_child_mutation, \"variables\": {\"id\": child_id, \"input\": update_input}},\n            timeout=TIMEOUT\n        )\n        update_resp.raise_for_status()\n        update_data = update_resp.json()\n        assert \"errors\" not in update_data, f\"Update child profile errors: {update_data.get('errors')}\"\n        updated_child = update_data[\"data\"][\"updateChildProfile\"]\n        assert updated_child[\"id\"] == child_id\n        assert updated_child[\"firstName\"] == update_input[\"firstName\"]\n        assert updated_child[\"lastName\"] == update_input[\"lastName\"]\n        assert updated_child[\"birthDate\"] == update_input[\"birthDate\"]\n        assert updated_child[\"gender\"] == update_input[\"gender\"]\n\n        get_resp_2 = requests.post(\n            BASE_URL,\n            headers=headers,\n            json={\"query\": get_child_query, \"variables\": {\"id\": child_id}},\n            timeout=TIMEOUT\n        )\n        get_resp_2.raise_for_status()\n        get_data_2 = get_resp_2.json()\n        assert \"errors\" not in get_data_2, f\"Get child profile errors: {get_data_2.get('errors')}\"\n        fetched_child_2 = get_data_2[\"data\"][\"childProfile\"]\n        assert fetched_child_2[\"firstName\"] == update_input[\"firstName\"]\n        assert fetched_child_2[\"lastName\"] == update_input[\"lastName\"]\n        assert fetched_child_2[\"birthDate\"] == update_input[\"birthDate\"]\n        assert fetched_child_2[\"gender\"] == update_input[\"gender\"]\n\n        no_auth_resp = requests.post(\n            BASE_URL,\n            json={\"query\": get_child_query, \"variables\": {\"id\": child_id}},\n            timeout=TIMEOUT\n        )\n        assert no_auth_resp.status_code == 200\n        no_auth_data = no_auth_resp.json()\n        assert \"errors\" in no_auth_data, \"Expected permission error without auth\"\n\n    finally:\n        if child_id:\n            del_resp = requests.post(\n                BASE_URL,\n                headers=headers,\n                json={\"query\": delete_child_mutation, \"variables\": {\"id\": child_id}},\n                timeout=TIMEOUT\n            )\n            if del_resp.status_code == 200:\n                _ = del_resp.json()\n\n\ntest_child_profile_management_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 187, in <module>\n  File \"<string>\", line 38, in test_child_profile_management_endpoints\n  File \"<string>\", line 32, in get_auth_token\nAssertionError: User missing in login response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:34.989Z",
    "modified": "2025-11-11T04:10:20.748Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "fdf250a6-8c6c-4e5a-95fe-b4d77a2d1307",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC004-test_inventory_management_endpoints",
    "description": "Check the inventory management endpoints to confirm diaper stock tracking with traffic light status updates, real-time synchronization, and offline capabilities.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add auth token here if authentication is required, e.g.\n    # \"Authorization\": \"Bearer <token>\"\n}\nTIMEOUT = 30\n\n\ndef graphql_query(query: str, variables=None):\n    payload = {\"query\": query}\n    if variables:\n        payload[\"variables\"] = variables\n    response = requests.post(BASE_URL, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    response.raise_for_status()\n    return response.json()\n\n\ndef test_inventory_management_endpoints():\n    # Step 1: Create a new child profile (required to associate inventory)\n    create_child_mutation = \"\"\"\n    mutation CreateChild($input: CreateChildInput!) {\n      createChild(input: $input) {\n        child {\n          id\n          name\n          birthDate\n        }\n        success\n        errors\n      }\n    }\n    \"\"\"\n    child_name = f\"Test Child {uuid.uuid4()}\"\n    child_birth_date = \"2024-01-01\"\n\n    try:\n        create_child_resp = graphql_query(create_child_mutation, {\"input\": {\"name\": child_name, \"birthDate\": child_birth_date}})\n        assert \"data\" in create_child_resp and create_child_resp[\"data\"] is not None, \"Missing data in createChild response\"\n        create_child_data = create_child_resp[\"data\"].get(\"createChild\")\n        assert create_child_data is not None and isinstance(create_child_data, dict), \"createChild response data is None or invalid\"\n        assert create_child_data.get(\"success\") is True, f\"Child creation failed: {create_child_data.get('errors')}\"\n        child_obj = create_child_data.get(\"child\")\n        assert child_obj is not None, \"Child object is missing in createChild response\"\n        child_id = child_obj.get(\"id\")\n        assert child_id, \"Created child ID is empty\"\n\n        # Step 2: Add an inventory item (diaper stock)\n        add_inventory_mutation = \"\"\"\n        mutation AddInventoryItem($input: AddInventoryInput!) {\n          addInventoryItem(input: $input) {\n            inventoryItem {\n              id\n              name\n              quantity\n              status\n            }\n            success\n            errors\n          }\n        }\n        \"\"\"\n        diaper_name = \"Disposable Diapers\"\n        initial_quantity = 50\n        add_inventory_resp = graphql_query(add_inventory_mutation, {\"input\": {\"childId\": child_id, \"name\": diaper_name, \"quantity\": initial_quantity}})\n        assert \"data\" in add_inventory_resp and add_inventory_resp[\"data\"] is not None, \"Missing data in addInventoryItem response\"\n        add_inventory_data = add_inventory_resp[\"data\"].get(\"addInventoryItem\")\n        assert add_inventory_data is not None and isinstance(add_inventory_data, dict), \"addInventoryItem response data is None or invalid\"\n        assert add_inventory_data.get(\"success\") is True, f\"Add inventory failed: {add_inventory_data.get('errors')}\"\n        inventory_item = add_inventory_data.get(\"inventoryItem\")\n        assert inventory_item is not None, \"Inventory item data is missing\"\n        inventory_id = inventory_item.get(\"id\")\n        assert inventory_id, \"Inventory item ID is empty\"\n        assert inventory_item.get(\"quantity\") == initial_quantity\n        assert inventory_item.get(\"status\") in [\"red\", \"yellow\", \"green\"], \"Inventory status invalid\"\n\n        # Step 3: Query inventory status and traffic light\n        inventory_status_query = \"\"\"\n        query InventoryStatus($childId: ID!) {\n          inventoryStatus(childId: $childId) {\n            id\n            name\n            quantity\n            status\n            lastUpdated\n          }\n        }\n        \"\"\"\n        inventory_status_resp = graphql_query(inventory_status_query, {\"childId\": child_id})\n        assert \"data\" in inventory_status_resp and inventory_status_resp[\"data\"] is not None, \"Missing data in inventoryStatus response\"\n        inventory_items = inventory_status_resp[\"data\"].get(\"inventoryStatus\")\n        assert inventory_items is not None, \"inventoryStatus data is None\"\n        assert any(item.get(\"id\") == inventory_id for item in inventory_items), \"Created inventory item not found\"\n        item = next(item for item in inventory_items if item.get(\"id\") == inventory_id)\n        assert item.get(\"quantity\") == initial_quantity\n        assert item.get(\"status\") in [\"red\", \"yellow\", \"green\"]\n\n        # Step 4: Update inventory quantity to trigger traffic light status change\n        update_inventory_mutation = \"\"\"\n        mutation UpdateInventoryQuantity($id: ID!, $quantity: Int!) {\n          updateInventoryQuantity(id: $id, quantity: $quantity) {\n            inventoryItem {\n              id\n              quantity\n              status\n            }\n            success\n            errors\n          }\n        }\n        \"\"\"\n        # Decrease quantity to low amount (e.g., 5) to expect 'red' or 'yellow' status\n        low_quantity = 5\n        update_inventory_resp = graphql_query(update_inventory_mutation, {\"id\": inventory_id, \"quantity\": low_quantity})\n        assert \"data\" in update_inventory_resp and update_inventory_resp[\"data\"] is not None, \"Missing data in updateInventoryQuantity response\"\n        update_inventory_data = update_inventory_resp[\"data\"].get(\"updateInventoryQuantity\")\n        assert update_inventory_data is not None and isinstance(update_inventory_data, dict), \"updateInventoryQuantity response data is None or invalid\"\n        assert update_inventory_data.get(\"success\") is True, f\"Update inventory failed: {update_inventory_data.get('errors')}\"\n        updated_item = update_inventory_data.get(\"inventoryItem\")\n        assert updated_item is not None, \"Updated inventory item is missing\"\n        assert updated_item.get(\"quantity\") == low_quantity\n        assert updated_item.get(\"status\") in [\"red\", \"yellow\"], \"Traffic light status did not update as expected for low quantity\"\n\n        # Step 5: Simulate real-time synchronization by querying inventory again (pretend from another user/device)\n        inventory_status_resp_2 = graphql_query(inventory_status_query, {\"childId\": child_id})\n        assert \"data\" in inventory_status_resp_2 and inventory_status_resp_2[\"data\"] is not None, \"Missing data in second inventoryStatus response\"\n        inventory_items_2 = inventory_status_resp_2[\"data\"].get(\"inventoryStatus\")\n        assert inventory_items_2 is not None, \"inventoryStatus data is None in second query\"\n        assert any(i.get(\"id\") == inventory_id and i.get(\"quantity\") == low_quantity for i in inventory_items_2), \"Real-time sync failed; updated inventory not reflected\"\n\n        # Step 6: Offline capability test - simulate by querying inventory status (should succeed)\n        # Here offline simulation is limited in API test, but verify fetch is successful and data is consistent\n        # (Actual offline sync is UI/client-side behavior)\n\n        assert inventory_items_2 is not None and len(inventory_items_2) > 0, \"Offline capability: inventory query returned no items\"\n\n    finally:\n        # Cleanup: delete inventory item and child profile to maintain test isolation\n        if 'inventory_id' in locals():\n            delete_inventory_mutation = \"\"\"\n            mutation DeleteInventoryItem($id: ID!) {\n              deleteInventoryItem(id: $id) {\n                success\n                errors\n              }\n            }\n            \"\"\"\n            try:\n                graphql_query(delete_inventory_mutation, {\"id\": inventory_id})\n            except Exception:\n                pass\n        if 'child_id' in locals():\n            delete_child_mutation = \"\"\"\n            mutation DeleteChild($id: ID!) {\n              deleteChild(id: $id) {\n                success\n                errors\n              }\n            }\n            \"\"\"\n            try:\n                graphql_query(delete_child_mutation, {\"id\": child_id})\n            except Exception:\n                pass\n\n\ntest_inventory_management_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 170, in <module>\n  File \"<string>\", line 42, in test_inventory_management_endpoints\nAssertionError: Missing data in createChild response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:34.995Z",
    "modified": "2025-11-11T04:10:22.914Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "36995fc6-fbd0-4d98-8ad4-156424ad926d",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC005-test_reorder_suggestions_endpoints",
    "description": "Test the ML-powered reorder suggestion APIs for providing accurate reorder timing, size-change predictions, retailer price comparisons, and emergency ordering functionality.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\n# Dummy user credentials for authentication (should be replaced with valid test credentials)\nTEST_USER_EMAIL = \"testuser@example.com\"\nTEST_USER_PASSWORD = \"TestPassword123!\"\n\ndef authenticate():\n    query = \"\"\"\n    mutation Login($email: String!, $password: String!) {\n      login(email: $email, password: $password) {\n        accessToken\n        user {\n          id\n          email\n        }\n      }\n    }\n    \"\"\"\n    variables = {\"email\": TEST_USER_EMAIL, \"password\": TEST_USER_PASSWORD}\n    response = requests.post(\n        BASE_URL,\n        json={\"query\": query, \"variables\": variables},\n        timeout=TIMEOUT\n    )\n    response.raise_for_status()\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response content is not valid JSON\"\n    assert data and isinstance(data, dict), \"Response JSON is empty or invalid\"\n    assert \"data\" in data and \"login\" in data[\"data\"] and data[\"data\"][\"login\"] is not None, \"Authentication failed: login field missing\"\n    access_token = data[\"data\"][\"login\"].get(\"accessToken\")\n    assert access_token and isinstance(access_token, str), \"Authentication failed: accessToken missing\"\n    return access_token\n\ndef create_child_profile(headers):\n    mutation = \"\"\"\n    mutation CreateChildProfile($input: ChildProfileCreateInput!) {\n      createChildProfile(input: $input) {\n        id\n        name\n        birthDate\n      }\n    }\n    \"\"\"\n    unique_name = \"TestChild_\" + str(uuid.uuid4())[:8]\n    variables = {\n        \"input\": {\n            \"name\": unique_name,\n            \"birthDate\": \"2023-01-01\",\n            \"gender\": \"Female\"\n        }\n    }\n    response = requests.post(\n        BASE_URL,\n        json={\"query\": mutation, \"variables\": variables},\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    response.raise_for_status()\n    data = response.json()\n    assert \"data\" in data and \"createChildProfile\" in data[\"data\"], \"Child profile creation failed\"\n    child_profile = data[\"data\"][\"createChildProfile\"]\n    assert \"id\" in child_profile, \"Child profile ID missing\"\n    return child_profile\n\ndef delete_child_profile(headers, child_id):\n    mutation = \"\"\"\n    mutation DeleteChildProfile($id: ID!) {\n      deleteChildProfile(id: $id) {\n        success\n      }\n    }\n    \"\"\"\n    variables = {\"id\": child_id}\n    response = requests.post(\n        BASE_URL,\n        json={\"query\": mutation, \"variables\": variables},\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    response.raise_for_status()\n    data = response.json()\n    # Deletion might return success true/false; if false, raise\n    assert \"data\" in data and \"deleteChildProfile\" in data[\"data\"], \"Child profile deletion failed\"\n    assert data[\"data\"][\"deleteChildProfile\"][\"success\"] is True, \"Child profile deletion not successful\"\n\ndef test_reorder_suggestions_endpoints():\n    access_token = authenticate()\n    headers = {\"Authorization\": f\"Bearer {access_token}\", \"Content-Type\": \"application/json\"}\n\n    # Create a child profile to associate reorder suggestions test with\n    child_profile = None\n    try:\n        child_profile = create_child_profile(headers)\n        child_id = child_profile[\"id\"]\n\n        # 1. Test reorder timing suggestion query\n        reorder_timing_query = \"\"\"\n        query ReorderTiming($childId: ID!) {\n          reorderTiming(childId: $childId) {\n            recommendedReorderDate\n            urgencyLevel\n          }\n        }\n        \"\"\"\n        variables = {\"childId\": child_id}\n        response = requests.post(\n            BASE_URL,\n            json={\"query\": reorder_timing_query, \"variables\": variables},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        assert \"data\" in data and \"reorderTiming\" in data[\"data\"], \"Reorder timing data missing\"\n        timing = data[\"data\"][\"reorderTiming\"]\n        assert \"recommendedReorderDate\" in timing and timing[\"recommendedReorderDate\"], \"Recommended reorder date missing\"\n        assert \"urgencyLevel\" in timing and timing[\"urgencyLevel\"] in [\"low\", \"medium\", \"high\"], \"Invalid urgency level\"\n\n        # 2. Test size-change prediction query\n        size_prediction_query = \"\"\"\n        query SizeChangePrediction($childId: ID!) {\n          sizeChangePrediction(childId: $childId) {\n            nextRecommendedSize\n            predictedChangeDate\n          }\n        }\n        \"\"\"\n        response = requests.post(\n            BASE_URL,\n            json={\"query\": size_prediction_query, \"variables\": variables},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        assert \"data\" in data and \"sizeChangePrediction\" in data[\"data\"], \"Size change prediction missing\"\n        size_pred = data[\"data\"][\"sizeChangePrediction\"]\n        assert \"nextRecommendedSize\" in size_pred and size_pred[\"nextRecommendedSize\"], \"Next size missing\"\n        assert \"predictedChangeDate\" in size_pred and size_pred[\"predictedChangeDate\"], \"Predicted change date missing\"\n\n        # 3. Test retailer price comparisons query\n        retailer_comparison_query = \"\"\"\n        query RetailerPriceComparison($childId: ID!) {\n          retailerPriceComparison(childId: $childId) {\n            retailerName\n            price\n            available\n          }\n        }\n        \"\"\"\n        response = requests.post(\n            BASE_URL,\n            json={\"query\": retailer_comparison_query, \"variables\": variables},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        assert \"data\" in data and \"retailerPriceComparison\" in data[\"data\"], \"Retailer price comparison missing\"\n        comparisons = data[\"data\"][\"retailerPriceComparison\"]\n        assert isinstance(comparisons, list), \"Retailer comparison should be a list\"\n        assert any(c.get(\"available\") for c in comparisons), \"At least one retailer should be available\"\n        for item in comparisons:\n            assert \"retailerName\" in item and item[\"retailerName\"], \"Retailer name missing\"\n            assert \"price\" in item and isinstance(item[\"price\"], (int, float)), \"Price missing or invalid\"\n            assert \"available\" in item and isinstance(item[\"available\"], bool), \"Availability missing or invalid\"\n\n        # 4. Test emergency order mutation (simulate emergency order placement)\n        emergency_order_mutation = \"\"\"\n        mutation EmergencyOrder($childId: ID!, $size: String!, $quantity: Int!) {\n          placeEmergencyOrder(childId: $childId, size: $size, quantity: $quantity) {\n            orderId\n            status\n            estimatedDelivery\n          }\n        }\n        \"\"\"\n        mutation_vars = {\"childId\": child_id, \"size\": size_pred[\"nextRecommendedSize\"], \"quantity\": 10}\n        response = requests.post(\n            BASE_URL,\n            json={\"query\": emergency_order_mutation, \"variables\": mutation_vars},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        assert \"data\" in data and \"placeEmergencyOrder\" in data[\"data\"], \"Emergency order result missing\"\n        order = data[\"data\"][\"placeEmergencyOrder\"]\n        assert \"orderId\" in order and order[\"orderId\"], \"Order ID missing\"\n        assert order.get(\"status\") in [\"pending\", \"confirmed\", \"processing\"], \"Unexpected order status\"\n        assert \"estimatedDelivery\" in order and order[\"estimatedDelivery\"], \"Estimated delivery missing\"\n\n    finally:\n        if child_profile:\n            delete_child_profile(headers, child_profile[\"id\"])\n\ntest_reorder_suggestions_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 203, in <module>\n  File \"<string>\", line 93, in test_reorder_suggestions_endpoints\n  File \"<string>\", line 35, in authenticate\nTypeError: argument of type 'NoneType' is not iterable\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.006Z",
    "modified": "2025-11-11T04:17:02.180Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "3931401f-c87c-4d1c-bb7b-b4477aea6c7e",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC006-test_analytics_dashboard_endpoints",
    "description": "Verify the analytics dashboard endpoints for loading usage patterns, cost summaries, predictions, and insights within performance targets.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n# Assume a valid token is obtained from a secure source or environment for authenticated requests\nAUTH_TOKEN = \"Bearer your_valid_auth_token_here\"\nHEADERS = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_analytics_dashboard_endpoints():\n    try:\n        # Query usage patterns\n        query_usage_patterns = {\n            \"query\": \"\"\"\n            query {\n                analytics {\n                    usagePatterns {\n                        patternType\n                        dataPoints {\n                            date\n                            value\n                        }\n                    }\n                }\n            }\n            \"\"\"\n        }\n        start_time = time.time()\n        resp = requests.post(BASE_URL, json=query_usage_patterns, headers=HEADERS, timeout=TIMEOUT)\n        duration = (time.time() - start_time) * 1000\n        assert resp.status_code == 200, f\"Expected 200, got {resp.status_code}\"\n        result = resp.json()\n        assert isinstance(result, dict) and result is not None, \"Response JSON is None or not a dictionary\"\n        assert 'data' in result and result['data'] is not None, \"Response 'data' field is missing or None\"\n        assert 'analytics' in result['data'] and result['data']['analytics'] is not None, \"Response 'analytics' field missing or None\"\n        usage_patterns = result['data']['analytics']['usagePatterns']\n        assert isinstance(usage_patterns, list)\n        # Performance target: under 500ms\n        assert duration < 500, f\"Usage patterns query took {duration}ms, exceeding 500ms\"\n\n        # Query cost summaries\n        query_cost_summaries = {\n            \"query\": \"\"\"\n            query {\n                analytics {\n                    costSummaries {\n                        totalCost\n                        categoryBreakdown {\n                            category\n                            cost\n                        }\n                    }\n                }\n            }\n            \"\"\"\n        }\n        start_time = time.time()\n        resp = requests.post(BASE_URL, json=query_cost_summaries, headers=HEADERS, timeout=TIMEOUT)\n        duration = (time.time() - start_time) * 1000\n        assert resp.status_code == 200, f\"Expected 200, got {resp.status_code}\"\n        result = resp.json()\n        assert isinstance(result, dict) and result is not None, \"Response JSON is None or not a dictionary\"\n        assert 'data' in result and result['data'] is not None, \"Response 'data' field is missing or None\"\n        cost_summaries = result['data']['analytics']['costSummaries']\n        assert 'totalCost' in cost_summaries\n        assert isinstance(cost_summaries['totalCost'], (int, float))\n        assert 'categoryBreakdown' in cost_summaries\n        assert isinstance(cost_summaries['categoryBreakdown'], list)\n        # Performance target\n        assert duration < 500, f\"Cost summaries query took {duration}ms, exceeding 500ms\"\n\n        # Query predictions\n        query_predictions = {\n            \"query\": \"\"\"\n            query {\n                analytics {\n                    predictions {\n                        nextReorderDate\n                        predictedSizes {\n                            size\n                            predictedUsage\n                        }\n                    }\n                }\n            }\n            \"\"\"\n        }\n        start_time = time.time()\n        resp = requests.post(BASE_URL, json=query_predictions, headers=HEADERS, timeout=TIMEOUT)\n        duration = (time.time() - start_time) * 1000\n        assert resp.status_code == 200, f\"Expected 200, got {resp.status_code}\"\n        result = resp.json()\n        assert isinstance(result, dict) and result is not None, \"Response JSON is None or not a dictionary\"\n        assert 'data' in result and result['data'] is not None, \"Response 'data' field is missing or None\"\n        predictions = result['data']['analytics']['predictions']\n        assert 'nextReorderDate' in predictions\n        assert isinstance(predictions['nextReorderDate'], str)\n        assert 'predictedSizes' in predictions\n        assert isinstance(predictions['predictedSizes'], list)\n        # Performance check\n        assert duration < 500, f\"Predictions query took {duration}ms, exceeding 500ms\"\n\n        # Query insights\n        query_insights = {\n            \"query\": \"\"\"\n            query {\n                analytics {\n                    insights {\n                        title\n                        description\n                        relevanceScore\n                    }\n                }\n            }\n            \"\"\"\n        }\n        start_time = time.time()\n        resp = requests.post(BASE_URL, json=query_insights, headers=HEADERS, timeout=TIMEOUT)\n        duration = (time.time() - start_time) * 1000\n        assert resp.status_code == 200, f\"Expected 200, got {resp.status_code}\"\n        result = resp.json()\n        assert isinstance(result, dict) and result is not None, \"Response JSON is None or not a dictionary\"\n        assert 'data' in result and result['data'] is not None, \"Response 'data' field is missing or None\"\n        insights = result['data']['analytics']['insights']\n        assert isinstance(insights, list)\n        for insight in insights:\n            assert 'title' in insight and isinstance(insight['title'], str)\n            assert 'description' in insight and isinstance(insight['description'], str)\n            assert 'relevanceScore' in insight and isinstance(insight['relevanceScore'], (int, float))\n        # Performance check\n        assert duration < 500, f\"Insights query took {duration}ms, exceeding 500ms\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_analytics_dashboard_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 140, in <module>\n  File \"<string>\", line 37, in test_analytics_dashboard_endpoints\nAssertionError: Response 'data' field is missing or None\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.014Z",
    "modified": "2025-11-11T04:10:07.087Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "02c85d04-201c-46a4-8d10-baf445bbc451",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC007-test_family_collaboration_endpoints",
    "description": "Validate real-time family collaboration APIs for presence indicators, shared shopping lists, role-based permissions, and conflict-free synchronization.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\n# Helper function to perform GraphQL queries/mutations\ndef graphql_request(query, variables=None, headers=None):\n    json_payload = {\"query\": query}\n    if variables is not None:\n        json_payload[\"variables\"] = variables\n    response = requests.post(BASE_URL, json=json_payload, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    return response.json()\n\n# Test family collaboration endpoints: presence indicators, shared shopping lists, role-based permissions, conflict-free sync\ndef test_family_collaboration_endpoints():\n    # Authentication: login user to get auth token\n    login_mutation = \"\"\"\n    mutation SignInUser($input: SignInInput!) {\n      signIn(input: $input) {\n        user {\n          id\n          email\n        }\n        token\n      }\n    }\n    \"\"\"\n    # Test user email and password, must exist in the system before test\n    email = \"testuser@example.com\"\n    password = \"StrongP@ssword123\"\n    login_variables = {\n        \"input\": {\n            \"email\": email,\n            \"password\": password\n        }\n    }\n    login_result = graphql_request(login_mutation, login_variables)\n    assert \"errors\" not in login_result, f\"Login failed: {login_result.get('errors')}\"\n    token = login_result[\"data\"][\"signIn\"][\"token\"]\n    assert token and isinstance(token, str)\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Create a child profile to associate with family collaboration tests\n    create_child_mutation = \"\"\"\n    mutation CreateChild($input: ChildCreateInput!) {\n      createChild(input: $input) {\n        child {\n          id\n          name\n          birthDate\n        }\n      }\n    }\n    \"\"\"\n    child_name = \"Test Child\"\n    child_birth_date = \"2024-01-01\"\n    create_child_variables = {\"input\": {\"name\": child_name, \"birthDate\": child_birth_date}}\n    create_child_result = graphql_request(create_child_mutation, create_child_variables, headers)\n    assert \"errors\" not in create_child_result, f\"Create child failed: {create_child_result.get('errors')}\"\n    child = create_child_result[\"data\"][\"createChild\"][\"child\"]\n    assert child[\"name\"] == child_name\n    child_id = child[\"id\"]\n\n    # Use try-finally to clean up created child profile\n    try:\n        # 1. Test presence indicators: query family members' presence status for the child\n        presence_query = \"\"\"\n        query GetPresenceIndicators($childId: ID!) {\n          familyPresence(childId: $childId) {\n            userId\n            userName\n            onlineStatus\n            lastSeen\n          }\n        }\n        \"\"\"\n        presence_variables = {\"childId\": child_id}\n        presence_result = graphql_request(presence_query, presence_variables, headers)\n        assert \"errors\" not in presence_result, f\"Presence indicators query error: {presence_result.get('errors')}\"\n        presence_list = presence_result[\"data\"][\"familyPresence\"]\n        assert isinstance(presence_list, list), \"Presence indicators should be a list\"\n        # Presence list items have keys userId, userName, onlineStatus, lastSeen (lastSeen may be None)\n        for presence in presence_list:\n            assert \"userId\" in presence\n            assert \"userName\" in presence\n            assert presence.get(\"onlineStatus\") in [\"online\", \"offline\", \"away\"]\n\n        # 2. Shared Shopping Lists: create shared shopping list, add item, get shopping lists\n        create_list_mutation = \"\"\"\n        mutation CreateShoppingList($input: ShoppingListCreateInput!) {\n          createShoppingList(input: $input) {\n            shoppingList {\n              id\n              name\n              shared\n            }\n          }\n        }\n        \"\"\"\n        list_name = \"Test Shared Shopping List\"\n        create_list_variables = {\"input\": {\"name\": list_name, \"shared\": True}}\n        create_list_result = graphql_request(create_list_mutation, create_list_variables, headers)\n        assert \"errors\" not in create_list_result, f\"Create shopping list failed: {create_list_result.get('errors')}\"\n        shopping_list = create_list_result[\"data\"][\"createShoppingList\"][\"shoppingList\"]\n        assert shopping_list[\"name\"] == list_name and shopping_list[\"shared\"] is True\n        shopping_list_id = shopping_list[\"id\"]\n\n        # Add item to shared shopping list\n        add_item_mutation = \"\"\"\n        mutation AddShoppingListItem($input: ShoppingListItemCreateInput!) {\n          addShoppingListItem(input: $input) {\n            item {\n              id\n              name\n              quantity\n              checked\n            }\n          }\n        }\n        \"\"\"\n        item_name = \"Diapers Size 3\"\n        add_item_variables = {\"input\": {\"shoppingListId\": shopping_list_id, \"name\": item_name, \"quantity\": 3}}\n        add_item_result = graphql_request(add_item_mutation, add_item_variables, headers)\n        assert \"errors\" not in add_item_result, f\"Add shopping list item failed: {add_item_result.get('errors')}\"\n        item = add_item_result[\"data\"][\"addShoppingListItem\"][\"item\"]\n        assert item[\"name\"] == item_name and item[\"quantity\"] == 3 and item[\"checked\"] is False\n        item_id = item[\"id\"]\n\n        # Query shopping lists with items\n        shopping_lists_query = \"\"\"\n        query ShoppingLists {\n          shoppingLists {\n            id\n            name\n            shared\n            items {\n              id\n              name\n              quantity\n              checked\n            }\n          }\n        }\n        \"\"\"\n        shopping_lists_result = graphql_request(shopping_lists_query, headers=headers)\n        assert \"errors\" not in shopping_lists_result, f\"Query shopping lists failed: {shopping_lists_result.get('errors')}\"\n        lists = shopping_lists_result[\"data\"][\"shoppingLists\"]\n        found_list = next((lst for lst in lists if lst[\"id\"] == shopping_list_id), None)\n        assert found_list is not None, \"Created shopping list not found in query\"\n        found_item = next((it for it in found_list[\"items\"] if it[\"id\"] == item_id), None)\n        assert found_item is not None, \"Added item not found in shopping list items\"\n\n        # 3. Role-based Permissions: check current user's role and try to update permissions\n        get_family_roles_query = \"\"\"\n        query GetFamilyRoles($childId: ID!) {\n          familyRoles(childId: $childId) {\n            userId\n            userName\n            role\n          }\n        }\n        \"\"\"\n        family_roles_result = graphql_request(get_family_roles_query, {\"childId\": child_id}, headers)\n        assert \"errors\" not in family_roles_result, f\"Query family roles failed: {family_roles_result.get('errors')}\"\n        roles = family_roles_result[\"data\"][\"familyRoles\"]\n        assert any(role[\"userId\"] for role in roles), \"Roles list should contain userIds\"\n\n        # Try to update role for a family member (assign self admin role for test)\n        # For safety, check if user has permission (simulate role update)\n        update_role_mutation = \"\"\"\n        mutation UpdateFamilyRole($input: FamilyRoleUpdateInput!) {\n          updateFamilyRole(input: $input) {\n            userId\n            role\n          }\n        }\n        \"\"\"\n        # Pick first user from roles list\n        target_user_id = roles[0][\"userId\"]\n        new_role = \"admin\"\n        update_role_variables = {\"input\": {\"childId\": child_id, \"userId\": target_user_id, \"role\": new_role}}\n        update_role_result = graphql_request(update_role_mutation, update_role_variables, headers)\n        # Either success or permission error, if permission error, validate proper error returned\n        if \"errors\" in update_role_result:\n            error_messages = [err[\"message\"].lower() for err in update_role_result[\"errors\"]]\n            assert any(\n                \"permission\" in msg or \"not authorized\" in msg or \"forbidden\" in msg for msg in error_messages\n            ), f\"Unexpected errors on role update: {error_messages}\"\n        else:\n            updated_role = update_role_result[\"data\"][\"updateFamilyRole\"]\n            assert updated_role[\"userId\"] == target_user_id\n            assert updated_role[\"role\"] == new_role\n\n        # 4. Conflict-free Synchronization: simulate concurrent update on shopping list item checked status\n        # Get current checked status and toggle it twice concurrently\n        toggle_checked_mutation = \"\"\"\n        mutation UpdateShoppingListItem($input: ShoppingListItemUpdateInput!) {\n          updateShoppingListItem(input: $input) {\n            item {\n              id\n              checked\n            }\n          }\n        }\n        \"\"\"\n        # Fetch item current checked status\n        item_checked = found_item[\"checked\"]\n        toggled_value_1 = not item_checked\n        toggled_value_2 = item_checked  # revert back\n\n        # Send first update\n        variables1 = {\"input\": {\"id\": item_id, \"checked\": toggled_value_1}}\n        resp1 = graphql_request(toggle_checked_mutation, variables1, headers)\n        assert \"errors\" not in resp1, f\"Error toggling checked status first update: {resp1.get('errors')}\"\n        updated1 = resp1[\"data\"][\"updateShoppingListItem\"][\"item\"]\n        assert updated1[\"checked\"] == toggled_value_1\n\n        # Send second update concurrent / immediately after\n        variables2 = {\"input\": {\"id\": item_id, \"checked\": toggled_value_2}}\n        resp2 = graphql_request(toggle_checked_mutation, variables2, headers)\n        assert \"errors\" not in resp2, f\"Error toggling checked status second update: {resp2.get('errors')}\"\n        updated2 = resp2[\"data\"][\"updateShoppingListItem\"][\"item\"]\n        assert updated2[\"checked\"] == toggled_value_2\n\n        # Final get to confirm state is consistent (should reflect last update)\n        shopping_lists_confirm = graphql_request(shopping_lists_query, headers=headers)\n        final_lists = shopping_lists_confirm[\"data\"][\"shoppingLists\"]\n        final_list = next((lst for lst in final_lists if lst[\"id\"] == shopping_list_id), None)\n        final_item = next((it for it in final_list[\"items\"] if it[\"id\"] == item_id), None)\n        assert final_item[\"checked\"] == toggled_value_2\n\n    finally:\n        # Cleanup: delete child profile and shopping list to avoid clutter\n        # Delete shopping list\n        delete_list_mutation = \"\"\"\n        mutation DeleteShoppingList($id: ID!) {\n          deleteShoppingList(id: $id) {\n            success\n          }\n        }\n        \"\"\"\n        try:\n            graphql_request(delete_list_mutation, {\"id\": shopping_list_id}, headers)\n        except Exception:\n            pass\n        # Delete child profile\n        delete_child_mutation = \"\"\"\n        mutation DeleteChild($id: ID!) {\n          deleteChild(id: $id) {\n            success\n          }\n        }\n        \"\"\"\n        try:\n            graphql_request(delete_child_mutation, {\"id\": child_id}, headers)\n        except Exception:\n            pass\n\n# Call the test function to execute\ntest_family_collaboration_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 263, in <module>\n  File \"<string>\", line 40, in test_family_collaboration_endpoints\nAssertionError: Login failed: [{'message': \"Cannot query field 'token' on type 'AuthResponse'.\", 'locations': [{'line': 8, 'column': 9}]}]\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.019Z",
    "modified": "2025-11-11T04:11:24.834Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "3b32bb96-e39c-4612-a2db-1545ee29c729",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC008-test_subscription_management_endpoints",
    "description": "Test subscription management endpoints including trial activation, billing, payment methods, and feature access control with Canadian tax compliance.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8001/graphql\"\nAUTH_TOKEN = None  # To be set after login or from environment/config\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"\",  # will be set once auth token acquired\n}\nTIMEOUT = 30\n\n\ndef graphql_request(query: str, variables: dict = None):\n    payload = {\"query\": query}\n    if variables:\n        payload[\"variables\"] = variables\n    response = requests.post(BASE_URL, headers=HEADERS, json=payload, timeout=TIMEOUT)\n    response.raise_for_status()\n    result = response.json()\n    if \"errors\" in result:\n        raise Exception(f\"GraphQL errors: {result['errors']}\")\n    return result[\"data\"]\n\n\ndef authenticate_user_and_set_token():\n    login_mutation = \"\"\"\n    mutation signIn($input: SignInInput!) {\n      signIn(input: $input) {\n        token\n        user {\n          id\n          email\n        }\n      }\n    }\n    \"\"\"\n    variables = {\n        \"input\": {\n            \"email\": \"testuser@example.com\",\n            \"password\": \"TestPassword123!\",\n        }\n    }\n    resp = requests.post(\n        BASE_URL,\n        headers={\"Content-Type\": \"application/json\"},\n        json={\"query\": login_mutation, \"variables\": variables},\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"errors\" not in data, f\"Login failed with errors: {data.get('errors')}\"\n    token = data.get(\"data\", {}).get(\"signIn\", {}).get(\"token\")\n    assert token, \"No access token received on login\"\n    global AUTH_TOKEN\n    AUTH_TOKEN = token\n    HEADERS[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n\n\ndef create_subscription_trial():\n    mutation = \"\"\"\n    mutation startTrial {\n      subscriptionStartTrial {\n        trialActive\n        trialEndDate\n      }\n    }\n    \"\"\"\n    return graphql_request(mutation)\n\n\ndef create_payment_method(card_number, exp_month, exp_year, cvc):\n    mutation = \"\"\"\n    mutation addPaymentMethod($input: PaymentMethodInput!) {\n      addPaymentMethod(input: $input) {\n        id\n        brand\n        last4\n        expMonth\n        expYear\n        isDefault\n      }\n    }\n    \"\"\"\n    variables = {\n        \"input\": {\n            \"cardNumber\": card_number,\n            \"expMonth\": exp_month,\n            \"expYear\": exp_year,\n            \"cvc\": cvc,\n            \"billingCountry\": \"CA\"\n        }\n    }\n    return graphql_request(mutation, variables)\n\n\ndef list_payment_methods():\n    query = \"\"\"\n    query {\n      paymentMethods {\n        id\n        brand\n        last4\n        expMonth\n        expYear\n        isDefault\n      }\n    }\n    \"\"\"\n    return graphql_request(query)\n\n\ndef activate_feature_access(featureKey: str):\n    mutation = \"\"\"\n    mutation activateFeature($featureKey: String!) {\n      subscriptionActivateFeatureAccess(featureKey: $featureKey) {\n        featureKey\n        enabled\n      }\n    }\n    \"\"\"\n    variables = {\"featureKey\": featureKey}\n    return graphql_request(mutation, variables)\n\n\ndef fetch_billing_history():\n    query = \"\"\"\n    query {\n      billingHistory {\n        id\n        date\n        amount\n        currency\n        status\n        taxAmount\n        taxRate\n      }\n    }\n    \"\"\"\n    return graphql_request(query)\n\n\ndef test_subscription_management_endpoints():\n    try:\n        # Authenticate user and set auth token header\n        authenticate_user_and_set_token()\n\n        # Activate Subscription Trial\n        trial_data = create_subscription_trial()\n        assert \"subscriptionStartTrial\" in trial_data, \"Trial activation failed\"\n        trial = trial_data[\"subscriptionStartTrial\"]\n        assert trial[\"trialActive\"] is True, \"Trial is not active after activation\"\n        assert trial[\"trialEndDate\"], \"Trial end date missing\"\n\n        # Add a valid Canadian payment method (mock card)\n        payment_method_data = create_payment_method(\n            card_number=\"4242424242424242\", exp_month=12, exp_year=2026, cvc=\"123\"\n        )\n        pm = payment_method_data.get(\"addPaymentMethod\")\n        assert pm is not None, \"Failed to add payment method\"\n        assert pm[\"brand\"], \"Payment method brand missing\"\n        assert pm[\"last4\"] == \"4242\", \"Payment method last4 incorrect\"\n        assert pm[\"expMonth\"] == 12, \"Expiration month mismatch\"\n        assert pm[\"expYear\"] == 2026, \"Expiration year mismatch\"\n\n        # Verify payment method appears in payment methods list\n        pm_list_data = list_payment_methods()\n        pm_list = pm_list_data.get(\"paymentMethods\", [])\n        assert any(p[\"id\"] == pm[\"id\"] for p in pm_list), \"Added payment method not in list\"\n\n        # Activate a feature access (premium feature)\n        feature_key = \"premium_feature_ocr_receipt_scanning\"\n        feature_access_data = activate_feature_access(feature_key)\n        fa = feature_access_data.get(\"subscriptionActivateFeatureAccess\")\n        assert fa is not None, \"Feature access activation failed\"\n        assert fa[\"featureKey\"] == feature_key, \"Feature key mismatch\"\n        assert fa[\"enabled\"] is True, \"Feature access not enabled\"\n\n        # Fetch billing history and verify Canadian tax compliance fields\n        billing_data = fetch_billing_history()\n        history = billing_data.get(\"billingHistory\", [])\n        for entry in history:\n            assert \"taxAmount\" in entry, \"Tax amount missing in billing history\"\n            assert entry[\"taxAmount\"] >= 0, \"Invalid tax amount\"\n            assert \"taxRate\" in entry, \"Tax rate missing in billing history\"\n            # Tax rate expected to be a valid percentage\n            assert 0 <= entry[\"taxRate\"] <= 0.15, \"Tax rate outside expected Canadian range\"\n\n    except Exception as e:\n        assert False, f\"Test failed with exception: {e}\"\n\n\ntest_subscription_management_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 146, in test_subscription_management_endpoints\n  File \"<string>\", line 52, in authenticate_user_and_set_token\nAssertionError: Login failed with errors: [{'message': \"Cannot query field 'token' on type 'AuthResponse'.\", 'locations': [{'line': 4, 'column': 9}]}]\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 193, in <module>\n  File \"<string>\", line 190, in test_subscription_management_endpoints\nAssertionError: Test failed with exception: Login failed with errors: [{'message': \"Cannot query field 'token' on type 'AuthResponse'.\", 'locations': [{'line': 4, 'column': 9}]}]\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.026Z",
    "modified": "2025-11-11T04:11:01.841Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "5804b45f-fb53-44f0-b196-3a9e3088fb86",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC009-test_consent_management_endpoints",
    "description": "Verify PIPEDA-compliant consent management APIs for user consent tracking, audit trails, just-in-time consent prompts, and data portability requests.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\n# Sample user credentials for authentication (adjust as needed)\nTEST_USER_EMAIL = \"testuser@example.com\"\nTEST_USER_PASSWORD = \"TestPassword123!\"\n\ndef authenticate_user(email: str, password: str) -> str:\n    \"\"\"Authenticate user and return auth token.\"\"\"\n    query = \"\"\"\n    mutation($input: SignInInput!) {\n      signIn(input: $input) {\n        accessToken\n        tokenType\n      }\n    }\n    \"\"\"\n    variables = {\"input\": {\"email\": email, \"password\": password}}\n    response = requests.post(BASE_URL, json={\"query\": query, \"variables\": variables}, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Login errors: {data.get('errors')}\"\n    token = data[\"data\"][\"signIn\"][\"accessToken\"]\n    assert token, \"No access token returned\"\n    return token\n\ndef create_consent(auth_token: str, consent_type: str, granted: bool) -> str:\n    \"\"\"Create a new consent record, returns the consent ID.\"\"\"\n    mutation = \"\"\"\n    mutation($input: ConsentCreateInput!) {\n      createConsent(input: $input) {\n        id\n        consentType\n        granted\n        timestamp\n      }\n    }\n    \"\"\"\n    variables = {\n        \"input\": {\n            \"consentType\": consent_type,\n            \"granted\": granted\n        }\n    }\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": mutation, \"variables\": variables}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Create consent errors: {data.get('errors')}\"\n    consent = data[\"data\"][\"createConsent\"]\n    assert consent[\"consentType\"] == consent_type\n    assert consent[\"granted\"] == granted\n    assert consent[\"id\"]\n    return consent[\"id\"]\n\ndef query_consent(auth_token: str, consent_id: str) -> dict:\n    \"\"\"Retrieve consent details by ID.\"\"\"\n    query = \"\"\"\n    query($id: ID!) {\n      consent(id: $id) {\n        id\n        consentType\n        granted\n        timestamp\n        auditTrail {\n          change\n          changedAt\n          changedBy\n        }\n      }\n    }\n    \"\"\"\n    variables = {\"id\": consent_id}\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": query, \"variables\": variables}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Query consent errors: {data.get('errors')}\"\n    consent = data[\"data\"][\"consent\"]\n    assert consent[\"id\"] == consent_id\n    return consent\n\ndef update_consent(auth_token: str, consent_id: str, granted: bool) -> dict:\n    \"\"\"Update consent granted status.\"\"\"\n    mutation = \"\"\"\n    mutation($id: ID!, $input: ConsentUpdateInput!) {\n      updateConsent(id: $id, input: $input) {\n        id\n        granted\n        timestamp\n      }\n    }\n    \"\"\"\n    variables = {\"id\": consent_id, \"input\": {\"granted\": granted}}\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": mutation, \"variables\": variables}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Update consent errors: {data.get('errors')}\"\n    updated_consent = data[\"data\"][\"updateConsent\"]\n    assert updated_consent[\"id\"] == consent_id\n    assert updated_consent[\"granted\"] == granted\n    return updated_consent\n\ndef delete_consent(auth_token: str, consent_id: str) -> bool:\n    \"\"\"Delete consent record.\"\"\"\n    mutation = \"\"\"\n    mutation($id: ID!) {\n      deleteConsent(id: $id)\n    }\n    \"\"\"\n    variables = {\"id\": consent_id}\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": mutation, \"variables\": variables}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Delete consent errors: {data.get('errors')}\"\n    return data[\"data\"][\"deleteConsent\"]\n\ndef jit_consent_prompt(auth_token: str, prompt_type: str) -> dict:\n    \"\"\"Simulate fetching a just-in-time consent prompt.\"\"\"\n    query = \"\"\"\n    query($promptType: String!) {\n      jitConsentPrompt(promptType: $promptType) {\n        promptId\n        title\n        description\n        required\n      }\n    }\n    \"\"\"\n    variables = {\"promptType\": prompt_type}\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": query, \"variables\": variables}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"JIT Consent Prompt errors: {data.get('errors')}\"\n    prompt = data[\"data\"][\"jitConsentPrompt\"]\n    assert prompt[\"promptId\"]\n    assert isinstance(prompt[\"required\"], bool)\n    return prompt\n\ndef request_data_portability(auth_token: str) -> dict:\n    \"\"\"Request user data for data portability.\"\"\"\n    query = \"\"\"\n    mutation {\n      requestDataPortability {\n        downloadUrl\n        expiresAt\n      }\n    }\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    response = requests.post(BASE_URL, json={\"query\": query}, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"errors\" not in data, f\"Data portability request errors: {data.get('errors')}\"\n    portability = data[\"data\"][\"requestDataPortability\"]\n    assert portability[\"downloadUrl\"]\n    assert portability[\"expiresAt\"]\n    return portability\n\ndef test_consent_management_endpoints():\n    # Authenticate the test user\n    token = authenticate_user(TEST_USER_EMAIL, TEST_USER_PASSWORD)\n\n    # Consent type to test (example: \"data_sharing\")\n    consent_type = \"data_sharing\"\n\n    consent_id = None\n    try:\n        # Create consent (grant = True)\n        consent_id = create_consent(token, consent_type, True)\n\n        # Retrieve and verify consent and audit trail present\n        consent = query_consent(token, consent_id)\n        assert consent[\"consentType\"] == consent_type\n        assert consent[\"granted\"] is True\n        assert isinstance(consent[\"auditTrail\"], list)\n\n        # Update consent to revoke (granted = False)\n        updated_consent = update_consent(token, consent_id, False)\n        assert updated_consent[\"granted\"] is False\n\n        # Fetch Just-in-Time consent prompt for a privacy setting\n        jit_prompt = jit_consent_prompt(token, prompt_type=\"data_sharing\")\n        assert \"title\" in jit_prompt and \"description\" in jit_prompt\n\n        # Request data portability export for the user\n        portability_info = request_data_portability(token)\n        assert portability_info[\"downloadUrl\"].startswith(\"http\")\n        assert portability_info[\"expiresAt\"]\n\n    finally:\n        # Cleanup: delete created consent if exists\n        if consent_id:\n            try:\n                deleted = delete_consent(token, consent_id)\n                assert deleted is True\n            except Exception:\n                pass\n\ntest_consent_management_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 205, in <module>\n  File \"<string>\", line 167, in test_consent_management_endpoints\n  File \"<string>\", line 24, in authenticate_user\nAssertionError: Login errors: [{'message': \"Cannot query field 'accessToken' on type 'AuthResponse'.\", 'locations': [{'line': 4, 'column': 9}]}, {'message': \"Cannot query field 'tokenType' on type 'AuthResponse'.\", 'locations': [{'line': 5, 'column': 9}]}]\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.031Z",
    "modified": "2025-11-11T04:11:14.457Z"
  },
  {
    "projectId": "8dfb4fdb-92f7-4392-91f8-456cc93f613f",
    "testId": "38fbc77a-2d28-4777-8e33-abf99fed6544",
    "userId": "74a8e4e8-8071-7034-51b9-4dc4f49cdc12",
    "title": "TC010-test_notification_system_endpoints",
    "description": "Check notification system endpoints for reliable push notification delivery, user preference adherence, and actionable responses.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8001/graphql\"\nTIMEOUT = 30\n\n# Using a sample user for auth workflow - replace with valid test user info if needed\nTEST_USER_EMAIL = \"testuser@example.com\"\nTEST_USER_PASSWORD = \"TestPass123!\"\n\ndef graphql_request(query, variables=None, token=None):\n    headers = {\"Content-Type\": \"application/json\"}\n    if token:\n        headers[\"Authorization\"] = f\"Bearer {token}\"\n    payload = {\"query\": query}\n    if variables is not None:\n        payload[\"variables\"] = variables\n    response = requests.post(BASE_URL, json=payload, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    return response.json()\n\ndef test_notification_system_endpoints():\n    # 1) Authenticate user to get token for notification endpoints\n    mutation_login = \"\"\"\n    mutation Login($email: String!, $password: String!) {\n      login(email: $email, password: $password) {\n        accessToken\n        user {\n          id\n          email\n        }\n        errors {\n          message\n        }\n      }\n    }\n    \"\"\"\n    login_vars = {\"email\": TEST_USER_EMAIL, \"password\": TEST_USER_PASSWORD}\n    login_resp = graphql_request(mutation_login, login_vars)\n    assert \"data\" in login_resp and \"login\" in login_resp[\"data\"], \"Login query failed\"\n    login_data = login_resp[\"data\"][\"login\"]\n    # Check for errors present and non-empty\n    if login_data.get(\"errors\") and len(login_data.get(\"errors\")) > 0:\n        assert False, f\"Login mutation returned errors: {login_data.get('errors')}\"\n    assert login_data.get(\"accessToken\") is not None, \"Login failed, no access token\"\n    token = login_data[\"accessToken\"]\n    user_id = login_data[\"user\"][\"id\"]\n    assert user_id is not None, \"User ID missing after login\"\n\n    # 2) Query current notification preferences\n    query_preferences = \"\"\"\n    query GetNotificationPreferences {\n      notificationPreferences {\n        id\n        userId\n        lowStockAlerts\n        reorderReminders\n        deliveryPreferences {\n          method\n          enabled\n        }\n      }\n    }\n    \"\"\"\n    pref_resp = graphql_request(query_preferences, token=token)\n    assert \"data\" in pref_resp and \"notificationPreferences\" in pref_resp[\"data\"], \"Failed to fetch notification preferences\"\n    prefs = pref_resp[\"data\"][\"notificationPreferences\"]\n    assert isinstance(prefs, dict), \"Notification preferences should be an object\"\n    assert prefs.get(\"userId\") == user_id, \"Notification preferences userId mismatch\"\n\n    # 3) Update notification preferences: Toggle lowStockAlerts to opposite value\n    current_low_stock = prefs.get(\"lowStockAlerts\", True)\n    mutation_update_pref = \"\"\"\n    mutation UpdateNotificationPreferences($input: NotificationPreferencesInput!) {\n      updateNotificationPreferences(input: $input) {\n        success\n        errors {\n          message\n        }\n        preferences {\n          lowStockAlerts\n          reorderReminders\n        }\n      }\n    }\n    \"\"\"\n    new_low_stock = not current_low_stock\n    update_vars = {\"input\": {\"lowStockAlerts\": new_low_stock}}\n    update_resp = graphql_request(mutation_update_pref, update_vars, token=token)\n    assert \"data\" in update_resp and \"updateNotificationPreferences\" in update_resp[\"data\"], \"Failed to update notification preferences\"\n    update_result = update_resp[\"data\"][\"updateNotificationPreferences\"]\n    assert update_result[\"success\"] is True, f\"Update preferences failed: {update_result.get('errors')}\"\n    updated_prefs = update_result[\"preferences\"]\n    assert updated_prefs[\"lowStockAlerts\"] == new_low_stock, \"Preference lowStockAlerts not updated correctly\"\n\n    # 4) Simulate sending a push notification for low stock alert (if API supports)\n    # We'll create a dummy notification entry and confirm it's created and can be queried\n    mutation_create_notification = \"\"\"\n    mutation CreateNotification($input: NotificationInput!) {\n      createNotification(input: $input) {\n        notification {\n          id\n          type\n          message\n          userId\n          status\n        }\n        errors {\n          message\n        }\n      }\n    }\n    \"\"\"\n    notif_message = f\"Low stock alert test message {uuid.uuid4()}\"\n    notif_vars = {\n        \"input\": {\n            \"type\": \"LOW_STOCK_ALERT\",\n            \"message\": notif_message,\n            \"userId\": user_id,\n            \"actionable\": True\n        }\n    }\n    create_notif_resp = graphql_request(mutation_create_notification, notif_vars, token=token)\n    assert \"data\" in create_notif_resp and \"createNotification\" in create_notif_resp[\"data\"], \"Failed to create notification\"\n    notif_data = create_notif_resp[\"data\"][\"createNotification\"]\n    assert notif_data[\"notification\"] is not None, f\"Notification creation failed: {notif_data.get('errors')}\"\n    notif_id = notif_data[\"notification\"][\"id\"]\n    assert notif_id is not None, \"Notification ID missing after creation\"\n\n    try:\n        # 5) Query notification by ID and validate contents\n        query_notification = \"\"\"\n        query GetNotification($id: ID!) {\n          notification(id: $id) {\n            id\n            type\n            message\n            userId\n            status\n          }\n        }\n        \"\"\"\n        query_vars = {\"id\": notif_id}\n        query_notif_resp = graphql_request(query_notification, query_vars, token=token)\n        assert \"data\" in query_notif_resp and \"notification\" in query_notif_resp[\"data\"], \"Failed to get notification\"\n        queried_notif = query_notif_resp[\"data\"][\"notification\"]\n        assert queried_notif[\"id\"] == notif_id, \"Queried notification ID mismatch\"\n        assert queried_notif[\"message\"] == notif_message, \"Notification message mismatch\"\n        assert queried_notif[\"userId\"] == user_id, \"Notification userId mismatch\"\n\n        # 6) Mark notification as read (actionable response)\n        mutation_mark_read = \"\"\"\n        mutation MarkNotificationRead($id: ID!) {\n          markNotificationRead(id: $id) {\n            success\n            errors {\n              message\n            }\n          }\n        }\n        \"\"\"\n        mark_read_vars = {\"id\": notif_id}\n        mark_resp = graphql_request(mutation_mark_read, mark_read_vars, token=token)\n        assert \"data\" in mark_resp and \"markNotificationRead\" in mark_resp[\"data\"], \"Failed to mark notification read\"\n        assert mark_resp[\"data\"][\"markNotificationRead\"][\"success\"] is True, f\"Mark notification read failed: {mark_resp['data']['markNotificationRead'].get('errors')}\"\n\n        # 7) Verify notification status changed to read\n        verification_resp = graphql_request(query_notification, query_vars, token=token)\n        notif_after = verification_resp[\"data\"][\"notification\"]\n        assert notif_after[\"status\"] == \"READ\", \"Notification status did not update to READ\"\n\n    finally:\n        # 8) Clean up: Delete created notification (if API supports)\n        mutation_delete_notification = \"\"\"\n        mutation DeleteNotification($id: ID!) {\n          deleteNotification(id: $id) {\n            success\n            errors {\n              message\n            }\n          }\n        }\n        \"\"\"\n        try:\n            delete_vars = {\"id\": notif_id}\n            del_resp = graphql_request(mutation_delete_notification, delete_vars, token=token)\n            assert \"data\" in del_resp and \"deleteNotification\" in del_resp[\"data\"], \"Failed to delete notification\"\n            assert del_resp[\"data\"][\"deleteNotification\"][\"success\"] is True, f\"Failed to delete notification: {del_resp['data']['deleteNotification'].get('errors')}\"\n        except Exception:\n            # Suppress any exception on cleanup to not mask test results\n            pass\n\ntest_notification_system_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 193, in <module>\n  File \"<string>\", line 40, in test_notification_system_endpoints\nTypeError: argument of type 'NoneType' is not iterable\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T04:08:35.037Z",
    "modified": "2025-11-11T04:11:17.565Z"
  }
]
